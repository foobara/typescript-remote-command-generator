import { Entity } from "<%= path_to_root %>base/Entity"
<% dependency_roots.each do |dependency_root| %>
import { <%= dependency_root.scoped_name %> } from "<%= path_to_root %><%= dependency_root.import_path %>"
<% end %>

export type <%= entity_name %>PrimaryKeyType = <%= primary_key_ts_type %>
export const <%= entity_name_downcase %>PrimaryKeyAttributeName: "<%= primary_key_name %>" = "<%= primary_key_name %>"
export interface <%= entity_name %>AttributesType <%= attributes_type_ts_type %>

export class <%= entity_name %><
  AttributesType extends <%= entity_name %>AttributesType = <%= entity_name %>AttributesType
> extends Entity<<%= entity_name %>PrimaryKeyType, AttributesType> {
  static readonly modelName: string = "<%= entity_name %>"
  static readonly entityName: string = "<%= entity_name %>"
  static readonly primaryKeyAttributeName: "<%= primary_key_name %>" = "<%= primary_key_name %>"

  get <%= primary_key_name %> (): <%= entity_name %>PrimaryKeyType {
    return this.primaryKey
  }

  get associationPropertyNames (): (keyof <%= entity_name %>AttributesType)[] { return <%= association_property_names_ts_array %> }
  readonly hasAssociations: <%= has_associations? %> = <%= has_associations? %>

  <% attribute_names.each do |attribute_name| %>
  get <%= attribute_name %> (): AttributesType["<%= attribute_name %>"] {
    return this.readAttribute("<%= attribute_name %>")
  }
  <% end %>

  get isAtom(): boolean {
    if (!this.isLoaded) {
      throw new Error("Record is not loaded so can't check if it's an atom")
    }

    if (!this.hasAssociations) {
      return true
    }

    <% associations.each_pair do |key, type| %>
      let o = this

      <% key.path.each do |k| %>
        <% if k == :"#" %>
        <% else %>
          o = o.<%= k %>
        <% end %>
      <% end %>
    <% end %>
    for (const propertyName of this.associationPropertyNames) {
      const record = this[propertyName as keyof this] as Entity<EntityPrimaryKeyType, Record<string, any>>

      if (record.isLoaded) {
        return false
      }
    }

    return true
  }

  _isAtom(path, object): booelan {

  }

  get isAggregate(): boolean {
    if (!this.isLoaded) {
      throw new Error("Record is not loaded so can't check if it's an aggregate")
    }

    if (!this.hasAssociations) {
      return true
    }

    for (const propertyName of this.associationPropertyNames) {
      const record = this[propertyName as keyof this] as Entity<EntityPrimaryKeyType, Record<string, any>>

      if (!record.isLoaded) {
        return false
      }

      if (!record.isAggregate) {
        return false
      }
    }

    return true
  }
}
